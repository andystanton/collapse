<html>

<head>
  <script type="text/javascript" src="node_modules/jquery/dist/jquery.min.js"></script>
  <script type="text/javascript" src="node_modules/dom-to-image/dist/dom-to-image.min.js"></script>
  <script type="text/javascript" src="node_modules/three/three.min.js"></script>
  <script type="text/javascript">
    var enable = true;

    if (enable) {
      var worker = new Worker('worker.js');
      worker.onmessage = function(message) {

      }

      $(window).load(function() {
        var disassemble = function(element, first) {
          function getPosition(element) {
            var leftPos = $(element)[0].getBoundingClientRect().left + $(window)['scrollLeft']();
            var rightPos = $(element)[0].getBoundingClientRect().right + $(window)['scrollLeft']();
            var topPos = $(element)[0].getBoundingClientRect().top + $(window)['scrollTop']();
            var bottomPos = $(element)[0].getBoundingClientRect().bottom + $(window)['scrollTop']();
            return {
              left: leftPos,
              right: rightPos,
              top: topPos,
              bottom: bottomPos
            }
          }

          var childPromises = [];
          if ($(element).find('.breakable').length) {
            $(element).children().each(function(i, child) {
              childPromises.push(disassemble(child));
            });
          }

          return Promise.all(childPromises).then(function(images) {
            if ($(element).hasClass("breakable")) {
              var position = getPosition(element);

              console.log($(element)[0].tagName + " " + $(element)[0].id)

              return domtoimage.toSvg($(element)[0]).then(function(dataUrl) {
                var img = new Image();
                img.src = dataUrl;

                // earlier items in the array will be drawn first (i.e. lower z order)
                var returnImages = [{
                  data: img,
                  position: getPosition($(element))
                }];

                for (var i = 0; i < images.length; ++i) {
                  returnImages = returnImages.concat(images[i])
                }

                $(element).css('visibility','hidden');

                return returnImages;
              })
            } else {
              return Promise.resolve(images[0]);
            }
          })
        }



        disassemble('body').then(function(images) {
          return images.map(function(imageWrapper) {
            var image = imageWrapper.data;
            var svgCanvas = $('<canvas>');
            var ctx = svgCanvas[0].getContext('2d');
            ctx.drawImage(image, 0, 0, image.width, image.height);
            var pixelData = ctx.getImageData(0, 0, image.width, image.height).data;
            svgCanvas.remove();
            imageWrapper.pixels = pixelData;
            console.log(imageWrapper)
            return imageWrapper;
          });
        }).then(function(images) {
          var scene = new THREE.Scene();
          var renderer = new THREE.WebGLRenderer({
            alpha: true
          });

          var camera = new THREE.OrthographicCamera(0, window.innerWidth, window.innerHeight, 0, 1, 1000);
          scene.add(camera);
          renderer.setSize(window.innerWidth, window.innerHeight);
          camera.position.z = 5;

          var rectLength = 1;
          var rectWidth = 1;
          var rectShape = new THREE.Shape();
          rectShape.moveTo(0, 0);
          rectShape.lineTo(0, rectWidth);
          rectShape.lineTo(rectLength, rectWidth);
          rectShape.lineTo(rectLength, 0);
          rectShape.lineTo(0, 0);
          rectGeom = new THREE.ShapeGeometry(rectShape);

          images.forEach(function(imageWrapper) {
            var image = imageWrapper.data;
            for (var x = 0; x < image.width; ++x) {
              for (var y = 0; y < image.height; ++y) {
                var pixelOffset = (x * 4) + (y * image.width * 4);
                var mesh = new THREE.Mesh(
                  rectGeom,
                  new THREE.MeshBasicMaterial({
                    color: new THREE.Color("rgb(" +
                      imageWrapper.pixels[pixelOffset + 0] + ", " +
                      imageWrapper.pixels[pixelOffset + 1] + ", " +
                      imageWrapper.pixels[pixelOffset + 2] + ")"),
                    opacity: imageWrapper.pixels[pixelOffset + 3],
                    transparent: true
                  }));
                mesh.position.x = x;
                mesh.position.y = window.innerHeight - y;
                scene.add(mesh)
              }
            }
          });

          var render = function() {
            requestAnimationFrame(render);
            renderer.render(scene, camera);
          };

          render();
          console.log("READY")
          $('body').append(renderer.domElement);
        });
      });
    }
  </script>
  <style type="text/css">
    .container-box {
      width: 200px;
      height: 100px;
      text-align: center;
      background-color: #6666CC;
    }

    .other {
      width: 100px;
      background-color: #EEEEBB
    }

    #foo {
      vertical-align: middle;
    }

    html {
      height: 100%;
      margin: 0;
    }

    body {
      margin: 0;
      min-height: 100%;
      background-color: #999999;
    }

    canvas {
      width: 100%;
      height: 100%;
      z-index: 2;
      position: absolute;
      top: 0px;
    }
  </style>
</head>

<body>
  <div id="container" class="container-box breakable">
    <div class="breakable" id="foo">foo!</div>
  </div>
  <div class="other">
    hello!
  </div>
</body>

</html>
